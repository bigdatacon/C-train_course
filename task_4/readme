Подсказка:
Попробуйте разные варианты:
как можно проще переиспользовать предыдущее решение;
применить вместо вектора легко объединяемый контейнер;
и что угодно ещё, что подскажет вам фантазия.

Задание
Это задание — часть итогового проекта девятого спринта. Вы будете сдавать его на проверку через репозиторий на GitHub. Не забудьте сохранить верное решение.
Напишите функцию ProcessQueriesJoined. Она должна, подобно функции ProcessQueries, распараллеливать обработку нескольких запросов к поисковой системе, но возвращать набор документов в плоском виде. Объявление функции:
/* набор объектов Document */ ProcessQueriesJoined(
    const SearchServer& search_server,
    const std::vector<std::string>& queries); 
Функция должна вернуть объект documents. Для него можно написать for (const Document& document : documents) и получить сначала все документы из результата вызова FindTopDocuments для первого запроса, затем для второго и так далее. Количество итераций такого цикла должно быть равно суммарному размеру внутренних векторов, возвращаемых функцией ProcessQueries.
Конкретный тип возвращаемого значения остаётся на ваше усмотрение: это может быть как vector<Document> или list<Document>, так и ваш собственный тип данных с определёнными методами begin и end. Главное — чтобы работал for, и скорость была приемлемой.
Пример
#include "process_queries.h"
#include "search_server.h"
#include <iostream>
#include <string>
#include <vector>
using namespace std;
int main() {
    SearchServer search_server("and with"s);
    int id = 0;
    for (
        const string& text : {
            "funny pet and nasty rat"s,
            "funny pet with curly hair"s,
            "funny pet and not very nasty rat"s,
            "pet with rat and rat and rat"s,
            "nasty rat with curly hair"s,
        }
    ) {
        search_server.AddDocument(++id, text, DocumentStatus::ACTUAL, {1, 2});
    }
    const vector<string> queries = {
        "nasty rat -not"s,
        "not very funny nasty pet"s,
        "curly hair"s
    };
    for (const Document& document : ProcessQueriesJoined(search_server, queries)) {
        cout << "Document "s << document.id << " matched with relevance "s << document.relevance << endl;
    }
    return 0;
} 
Вывод:
Document 1 matched with relevance 0.183492
Document 5 matched with relevance 0.183492
Document 4 matched with relevance 0.167358
Document 3 matched with relevance 0.743945
Document 1 matched with relevance 0.311199
Document 2 matched with relevance 0.183492
Document 5 matched with relevance 0.127706
Document 4 matched with relevance 0.0557859
Document 2 matched with relevance 0.458145
Document 5 matched with relevance 0.458145 
Ограничения
Поисковые запросы корректны и не порождают исключений.
Что отправлять на проверку
Заголовочные файлы и файлы с реализацией, содержащие класс SearchServer, написанные ранее вспомогательные функции и новую функцию ProcessQueriesJoined. Функция main будет проигнорирована.
Как будет тестироваться ваш код
Правильность работы функции будет проверена юнит-тестами.
Как и в предыдущей задаче, время работы вашей функции должно быть по крайней мере вдвое меньше, чем у тривиального решения с последовательными вызовами FindTopDocuments.
Мы проверим это на таких входных данных:
поисковая система из 20 000 документов, не более 10 слов в каждом;
2 000 поисковых запросов, не более 7 слов в каждом;
все слова — из словаря, состоящего из 2 000 слов длиной не более 25 букв.
