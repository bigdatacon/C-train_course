Подсказка:
Вы можете столкнуться с тем, что нужный алгоритм не параллелится, когда передаёте в него итераторы не произвольного доступа.
Попробуйте переложить нужные элементы в вектор и запустить алгоритм для него.

Задание
Задание 1
Это задание — часть итогового проекта восьмого спринта. Вы будете сдавать его на проверку через репозиторий на GitHub. Не забудьте сохранить верное решение.
Реализуйте многопоточную версию метода RemoveDocument в дополнение к однопоточной.
Пример
#include "search_server.h"

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int main() {
    SearchServer search_server("and with"s);

    int id = 0;
    for (
        const string& text : {
            "funny pet and nasty rat"s,
            "funny pet with curly hair"s,
            "funny pet and not very nasty rat"s,
            "pet with rat and rat and rat"s,
            "nasty rat with curly hair"s,
        }
    ) {
        search_server.AddDocument(++id, text, DocumentStatus::ACTUAL, {1, 2});
    }

    const string query = "curly and funny"s;

    auto report = [&search_server, &query] {
        cout << search_server.GetDocumentCount() << " documents total, "s
            << search_server.FindTopDocuments(query).size() << " documents for query ["s << query << "]"s << endl;
    };

    report();
    // однопоточная версия
    search_server.RemoveDocument(5);
    report();
    // однопоточная версия
    search_server.RemoveDocument(execution::seq, 1);
    report();
    // многопоточная версия
    search_server.RemoveDocument(execution::par, 2);
    report();

    return 0;
} 
Вывод:
5 documents total, 4 documents for query [curly and funny]
4 documents total, 3 documents for query [curly and funny]
3 documents total, 2 documents for query [curly and funny]
2 documents total, 1 documents for query [curly and funny] 
Ограничения
Как и прежде, в метод RemoveDocument может быть передан любой document_id. Если такой документ отсутствует, метод должен немедленно завершиться.
