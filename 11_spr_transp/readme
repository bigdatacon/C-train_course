Подсказка: 
Не пытайтесь сразу решить задачу: слона нужно есть постепенно. Сначала адаптируйте своё старое решение под новую структуру модулей. Убедитесь, что код транспортного справочника не зависит от модулей, отвечающих за ввод-вывод данных. После этого переведите приложение на использование формата JSON.
Массив base_requests содержит информацию об автобусных маршрутах и остановках в произвольном порядке. Обработайте его в два прохода: сначала описания остановок, а затем — описания маршрутов.
Следите, чтобы размер методов и функций не был слишком большим. Если функция выполняет несколько задач, есть смысл вынести эти задачи в подфункции. Как правило, каждый цикл внутри функции выполняет определённый алгоритм и может быть вынесен в отдельный метод с понятным именем. Так вы уменьшите сложность программы и облегчите её сопровождение.
Для классов и функций со сложной логикой напишите модульные тесты. Так вы вовремя обнаружите ошибки, которые могут возникнуть при изменениях.

Задание
Это задание — итоговый проект десятого спринта. Вы будете сдавать его на проверку через репозиторий на GitHub. Не забудьте сохранить верное решение.
Задание посвящено переводу приложения на ввод-вывод в формате JSON.
Формат входных данных
Данные поступают из stdin в формате JSON-объекта. Его верхнеуровневая структура:
{
  "base_requests": [ ... ],
  "stat_requests": [ ... ]
} 
Это словарь, содержащий ключи:
base_requests — массив с описанием автобусных маршрутов и остановок,
stat_requests — массив с запросами к транспортному справочнику.
Внимание, JSON может быть отформатирован произвольным образом: использовать или не использовать пробелы для отступов, ключи объектов могут быть расположены в разных строках или в одной. Следующие JSON-данные эквивалентны:
{"base_requests":[],"stat_requests":[]} 
{
  "stat_requests": [],
  "base_requests": []
} 
{
    "base_requests":     [
]
,
"stat_requests":[]
} 
Иными словами, разделительные пробелы, табуляции и символы перевода строки внутри JSON могут располагаться произвольным образом или вообще отсутствовать.
Описание базы маршрутов
Массив base_requests содержит элементы двух типов: маршруты и остановки. Они перечисляются в произвольном порядке.
Пример описания остановки:
{
  "type": "Stop",
  "name": "Электросети",
  "latitude": 43.598701,
  "longitude": 39.730623,
  "road_distances": {
    "Улица Докучаева": 3000,
    "Улица Лизы Чайкиной": 4300
  }
} 
image

Остановка «Электросети»
Описание остановки — словарь с ключами:
type — строка, равная "Stop". Означает, что словарь описывает остановку;
name — название остановки;
latitude и longitude — широта и долгота остановки — числа с плавающей запятой;
road_distances — словарь, задающий дорожное расстояние от этой остановки до соседних. Каждый ключ в этом словаре — название соседней остановки, значение — целочисленное расстояние в метрах.
Пример описания автобусного маршрута:
{
  "type": "Bus",
  "name": "14",
  "stops": [
    "Улица Лизы Чайкиной",
    "Электросети",
    "Улица Докучаева",
    "Улица Лизы Чайкиной"
  ],
  "is_roundtrip": true
} 
image

Описание кольцевого маршрута «14 »
Описание автобусного маршрута — словарь с ключами:
type — строка "Bus". Означает, что словарь описывает автобусный маршрут;
name — название маршрута;
stops — массив с названиями остановок, через которые проходит маршрут. У кольцевого маршрута название последней остановки дублирует название первой. Например: ["stop1", "stop2", "stop3", "stop1"];
is_roundtrip — значение типа bool. true, если маршрут кольцевой.
Формат запросов к транспортному справочнику и ответов на них
Запросы хранятся в массиве stat_requests. В ответ на них программа должна вывести в stdout JSON-массив ответов:
[
  { ответ на первый запрос },
  { ответ на второй запрос },
  ...
  { ответ на последний запрос }
] 
Каждый запрос — словарь с обязательными ключами id и type. Они задают уникальный числовой идентификатор запроса и его тип. В словаре могут быть и другие ключи, специфичные для конкретного типа запроса.
В выходном JSON-массиве на каждый запрос stat_requests должен быть ответ в виде словаря с обязательным ключом request_id. Значение ключа должно быть равно id соответствующего запроса. В словаре возможны и другие ключи, специфичные для конкретного типа ответа.
Порядок следования ответов на запросы в выходном массиве должен совпадать с порядком запросов в массиве stat_requests.
Получение информации о маршруте
Формат запроса:
{
  "id": 12345678,
  "type": "Bus",
  "name": "14"
} 
Ключ type имеет значение “Bus”. По нему можно определить, что это запрос на получение информации о маршруте.
Ключ name задаёт название маршрута, для которого приложение должно вывести статистическую информацию.
Ответ на этот запрос должен быть дан в виде словаря:
{
  "curvature": 2.18604,
  "request_id": 12345678,
  "route_length": 9300,
  "stop_count": 4,
  "unique_stop_count": 3
} 
Ключи словаря:
curvature — извилистость маршрута. Она равна отношению длины дорожного расстояния маршрута к длине географического расстояния. Число типа double;
request_id — должен быть равен id соответствующего запроса Bus. Целое число;
route_length — длина дорожного расстояния маршрута в метрах, целое число;
stop_count — количество остановок на маршруте;
unique_stop_count — количество уникальных остановок на маршруте.
Например, на кольцевом маршруте с остановками A, B, C, A четыре остановки. Три из них уникальные.
На некольцевом маршруте с остановками A, B и C пять остановок (A, B, C, B, A). Три из них уникальные.
Если в справочнике нет маршрута с указанным названием, ответ должен быть таким:
{
  "request_id": 12345678,
  "error_message": "not found"
} 
Получение информации об остановке
Формат запроса:
{
  "id": 12345,
  "type": "Stop",
  "name": "Улица Докучаева"
} 
Ключ name задаёт название остановки.
Ответ на запрос:
{
  "buses": [
      "14", "22к"
  ],
  "request_id": 12345
} 
Значение ключей ответа:
buses — массив названий маршрутов, которые проходят через эту остановку. Названия отсортированы в лексикографическом порядке.
request_id — целое число, равное id соответствующего запроса Stop.
Если в справочнике нет остановки с переданным названием, ответ на запрос должен быть такой:
{
  "request_id": 12345,
  "error_message": "not found"
} 
Примеры входных и выходных данных
Этот JSON-документ содержит:
описание маршрута «114», который соединяет две остановки: «Морской вокзал»‎ и «Ривьерский мост»‎,
запросы на получение информации о маршруте «114» и остановке «Ривьерский мост».
input.json
{
  "base_requests": [
    {
      "type": "Bus",
      "name": "114",
      "stops": ["Морской вокзал", "Ривьерский мост"],
      "is_roundtrip": false
    },
    {
      "type": "Stop",
      "name": "Ривьерский мост",
      "latitude": 43.587795,
      "longitude": 39.716901,
      "road_distances": {"Морской вокзал": 850}
    },
    {
      "type": "Stop",
      "name": "Морской вокзал",
      "latitude": 43.581969,
      "longitude": 39.719848,
      "road_distances": {"Ривьерский мост": 850}
    }
  ],
  "stat_requests": [
    { "id": 1, "type": "Stop", "name": "Ривьерский мост" },
    { "id": 2, "type": "Bus", "name": "114" }
  ]
} 
image

Схематическое представление маршрута «114»
Ожидаемый вывод программы:
output.json
[
    {
        "buses": [
            "114"
        ],
        "request_id": 1
    },
    {
        "curvature": 1.23199,
        "request_id": 2,
        "route_length": 1700,
        "stop_count": 3,
        "unique_stop_count": 2
    }
] 
Семантика JSON-документа не должна меняться. Ваш вывод может отличаться:
В отступах и форматировании;
В порядке ключей в словаре. Элементов массива это не касается.
Вещественные числа выводите стандартно, без модификаторов.
Примечания
В примерах названия написаны кириллицей для простоты. Вы можете работать со строками, как раньше. Если на вашем компьютере названия из примера выводятся некорректно, замените буквы латинскими. Тесты в тренажёре содержат только буквы английского алфавита.
Перенаправление ввода-вывода в файл
Чтобы не вводить каждый раз содержимое JSON-документа вручную, сохраните входной JSON-документ в файл и запускайте программу с перенаправлением ввода из этого файла:
program.exe <input.json 
Программа будет считывать стандартный ввод не из консоли, а из файла input.json. При необходимости stdout программы тоже можно перенаправить в файл:
program.exe <input.json >output.json 
Перенаправить в файл можно и стандартный поток ошибок: 
для потока stderr поставьте перед именем файла 2>;
для потока stdout поставьте перед именем файла 1>.
program.exe <input.json 1>stdout.txt 2>stderr.txt 
Так, в программе ввод из cin будет считывать содержимое input.json, вывод в cout станет записываться в файл stdout.txt, а вывод в cerr — записываться в файл stderr.txt.
При работе в IDE перенаправление потоков ввода можно настроить в параметрах запуска или отладки.
Рекомендации по архитектуре
Вам предстоит разработать объёмное приложение. Оно решает такие задачи:
парсинг JSON и вывод JSON;
построение базы маршрутов;
обработка запросов к справочнику и формирование ответов на них.
Чтобы поддерживать приложение было легко, подумайте об архитектуре. Разбейте код на модули, каждый из которых решает определённую задачу. Под модулем здесь понимается пара файлов .h/.cpp с классами и функциями. Код в одном модуле может зависеть от кода других модулей. Некоторые модули могут быть самостоятельными.
Предлагаем вам организовать структуру программы в виде следующих модулей:
geo — объявляет координаты на земной поверхности и вычисляет расстояние между ними;
domain — классы основных сущностей, описывают автобусы и остановки;
transport_catalogue — модуль транспортного каталога;
request_handler — обрабатывает запросы. Играет роль Фасада, который упрощает взаимодействие с транспортным каталогом;
json — ваша улучшенная библиотека для парсинга и вывода JSON;
json_reader — выполняет разбор JSON-данных, построенных в ходе парсинга, и формирует массив JSON-ответов;
main — основной модуль.
В заготовке кода — файлы других модулей: svg и map_renderer. Они понадобятся в следующем уроке.
На схеме — рекомендуемая карта зависимостей между модулями программы. Один модуль зависит от другого, когда использует его функции и классы или наследуется от классов, объявленных в другом модуле.
image
Каждый модуль можно отнести к определённому слою приложения. На верхнем уровне — объекты предметной области и бизнес-логика. На нижнем — объекты инфраструктуры, которые отвечают за ввод-вывод и взаимодействие с внешними системами. Библиотека для парсинга JSON не зависит от классов приложения. Поэтому её можно использовать в различных приложениях.
В хороших архитектурах объекты верхних уровней не зависят от объектов более нижних. Это позволяет заменять детали реализации нижних слоёв, не влияя на логику работы приложения. Например, здесь можно переписать ввод-вывод с JSON на XML, просто заменив модуль json_reader на xml_reader. На остальных модулях это не отразится. А вот изменения в transport_catalogue могут повлиять на request_handler, json_reader и main. Модуль, от которого зависят другие, должен быть стабильным. Иначе всё превратится в хаос.
В ходе разработки между модулями иногда появляются новые зависимости. Например, у json_reader могут возникнуть зависимости от маршрутов и остановок из domain. Это нормально, так как json_reader — модуль нижнего уровня и может зависеть от модуля высокого уровня. А вот модули верхнего уровня не должны зависеть от модулей нижнего. Циклических зависимостей между модулями тоже следует избегать. Они усложняют поддержку кода.
В задании не регламентируется, из каких классов и функций должна состоять ваша программа и в каких файлах они будут располагаться. Но схема выше здорово облегчит вам задачу.
Как будет тестироваться ваш код
Программа получит из stdin валидный JSON-документ с описанием маршрутов и запросов к справочнику. Данные, которые программа выведет в stdout, будут сравниваться с ожидаемым значением. Вывод вещественных чисел должен осуществляться стандартно, без модификаторов вывода.
Вы можете рассчитывать на следующие объёмы входных данных:
Количество запросов на создание маршрутов и остановок — не более 100.
Количество запросов к уже созданной базе — не более 2000.
Не более 100 остановок в маршруте.
Время работы программы на указанном объёме данных не должно превышать одной секунды.
