Подсказка о том, как реализовать метод FindByNamePrefix за 
�
(
log
⁡
�
)
O(logN), есть в условии: «Метод FindByNamePrefix должен возвращать диапазон ... контактов ..., отсортированный лексикографически».
Подумайте, как будут расположены контакты, имена которых начинаются на один и тот же префикс, если сложить все контакты в вектор и отсортировать алгоритмом sort.
Контакты, начинающиеся на один префикс, будут образовывать непрерывный диапазон в отсортированном векторе. Для поиска таких диапазонов можно использовать lower_bound и upper_bound.
Контейнер хранит контакты, а поиск делается по string_view. Тут важно учитывать разницу между компараторами lower_bound и upper_bound:
компаратор lower_bound сравнивает элемент контейнера с искомым значением, он имеет вид: [](const Contact& l, std::string_view r){...}
компаратор upper_bound делает наоборот, он имеет вид: [](std::string_view l, const Contact& r){...}.
Для поиска нижней границы диапазона алгоритмом lower_bound можно использовать обычное сравнение.
Для поиска верхней границы алгоритмом upper_bound простое сравнение не подходит: строчка “Margarita Astapova” лексикографически больше, чем “Margarita”. Используйте компаратор, который сравнивает только префикс строки. Он должен обрезать строку “Margarita Astapova” по длине искомого префикса.

Задание
Разработайте класс PhoneBook для адресной книги мобильного телефона. Класс должен решать три задачи:
Сериализация контактов в выходной поток. Например, для сохранения её в памяти телефона или для отправки на сервер синхронизации контактов.
Десериализация контактов из входного потока.
Поиск контактов, имя которых начинается на заданную строку. Эта функция полезна, когда пользователь вводит имя, а адресная книга показывает ему все контакты, имя которых начинается с введённой строки.
Контакт в вашей адресной книге может иметь следующие характеристики:
Имя — всегда есть, но может быть пустым.
Дата рождения — может быть не задана.
Номера телефона — может быть ноль или больше.
Отрабатываются разные сценарии использования телефонной книги:
Записать день рождения человека, чтобы не забыть — имя и дата рождения есть, номеров телефона нет.
Хранить несколько номеров знакомого человека — имя есть, есть один или несколько номеров телефона, дата рождения не задана.
Собирать всю информацию о человеке в одном месте — есть имя, дата рождения, один или несколько номеров телефона.
Иметь несколько номеров телефона с пустым именем и без даты рождения — например, для тренировки памяти.
Таким образом, мы можем представить контакт в адресной книге в виде структуры:
struct Date {
    int year, month, day;
};

struct Contact {
    std::string name;
    std::optional<Date> birthday;
    std::vector<std::string> phones;
};
 
Интерфейс класса PhoneBook будет выглядеть так:
class PhoneBook {
public:
    explicit PhoneBook(std::vector<Contact> contacts);

    IteratorRange<???> FindByNamePrefix(std::string_view name_prefix) const;
    void SaveTo(std::ostream& output) const;

private:
    // ...
};

PhoneBook DeserializePhoneBook(std::istream& input);
 
Для сериализации и десериализации класс PhoneBook должен использовать Protobuf. Proto-файл разработайте сами с учётом следующих требований:
он должен определять пакет phone_book_serialize;
в нём должно быть сообщение Date, для хранения года, месяца и дня;
в нём должно быть сообщение Contact, используемое для сериализации одного контакта;
в нём должно быть сообщение ContactList, содержащее одно repeated-поле типа Contact;
поля сообщений Date, ContactList и Contact будут ясны из юнит-тестов заготовки.
Метод FindByNamePrefix должен возвращать отсортированный лексикографически диапазон всех контактов, имя которых начинается на строку name_prefix. Если name_prefix — это пустая строка, метод FindByNamePrefix должен возвращать диапазон, содержащий все контакты адресной книги, в том числе те, у которых имя пустое.
Формат входных данных
Функция DeserializePhoneBook принимает на вход поток, содержащий представление, полученное в результате вызова PhoneBook::SaveTo.
Формат выходных данных
Изучите юнит-тесты из заготовки, чтобы понять, какие поля должны быть в сообщениях proto-файла.
Ограничения
Метод FindByNamePrefix должен работать быстрее, чем $O(N)$, где $N$ — количество контактов в адресной книге.
Для сериализации должен использоваться Protobuf.
Пример
Пример в юнит-тестах заготовки кода.
Что отправлять на проверку
Напишите в файле phone_book.cpp реализации функций и методов, декларированных в phone_book.h.
В файле contact.proto реализуйте описанную выше proto-схему.
Как будет тестироваться ваш код
Ваш код будет тестироваться аналогично юнит-тестам, приведённым в файле main.cpp ниже.
Мы проверим, что метод SaveTo сохраняет контакты в созданную вами proto-схему
Проверим, что функция DeserializePhoneBook загружает адресную книгу из proto-сообщения ContactList
Проверим, что метод FindByNamePrefix корректно работает для десериализованной адресной книги
Проверим производительность метода FindByNamePrefix
