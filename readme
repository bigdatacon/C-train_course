Задание:
Задание
Разработайте шаблонный класс SimpleVector<Type>, который будет упрощённым аналогом контейнера vector, со следующим функционалом:
Конструкторы.
По умолчанию. Создаёт пустой вектор с нулевой вместимостью. Не выделяет динамическую память и не выбрасывает исключений.
Параметризованный конструктор, создающий вектор заданного размера. Элементы вектора инициализированы значением по умолчанию для типа Type. Вектор должен иметь одинаковые размер и вместимость. Если размер нулевой, динамическая память для его элементов выделяться не должна.
Конструктор из std::initializer_list. Элементы вектора должны содержать копию элементов initializer_list. Имеет размер и вместимость, совпадающую с размерами и вместимостью переданного initializer_list.
Метод GetSize для получения количества элементов в векторе. Не выбрасывает исключений.
Метод GetCapacity для получения вместимости вектора. Не выбрасывает исключений.
Метод IsEmpty, сообщающий, пуст ли вектор. Не выбрасывает исключений.
Оператор [] для доступа к элементу вектора по его индексу. Имеет две версии — константную и неконстантную. Не выбрасывает исключений. Для корректной работы оператора индекс элемента массива не должен выходить за пределы массива.
Метод At для доступа к элементу вектора по его индексу, аналог метода at класса vector. В случае выхода индекса за пределы массива должен выбросить исключение std::out_of_range.
Метод Clear для очистки массива без изменения его вместимости. Не выбрасывает исключений.
Метод Resize для изменения количества элементов в массиве. Метод должен предоставлять строгую гарантию безопасности исключений.
Методы begin, end, cbegin и cend, возвращающие итераторы на начало и конец массива. В качестве итераторов используйте указатели. Эти методы должны быть объявлены со спецификатором noexcept. В противном случае тренажёр отклонит ваше решение.
При разрушении вектора должна освобождаться память, занимаемая его элементами.
Ограничения
Гарантируется, что тренажёр при проверке решения не будет передавать в оператор [] индексы, выходящие за границы массива. При написании  SimpleVector реализуйте самостоятельно работу с массивом в динамической памяти. Чтобы упростить управление массивом, пригодится разработанный в предыдущем спринте шаблонный класс ArrayPtr. Не используйте класс std::vector.
Что отправлять на проверку
Файл simple_vector.h с исходным кодом класса SimpleVector. Если нужно включить дополнительные заголовочные файлы, например, с кодом ArrayPtr, отправьте их тоже. Если загрузите функцию main, она будет заменена на версию из тренажёра.
Как будет тестироваться ваш код
Сохраните сигнатуру методов класса SimpleVector неизменной, чтобы код скомпилировался без ошибок, а тренажёр не отклонил ваше решение. Это особенно касается спецификатора noexcept.

Подсказка:
В методе Resize отдельно обработайте три ситуации: новый размер меньше или равен текущему, новый размер не превышает его вместимости, новый размер превышает текущую вместимость вектора.
Если при изменении размера массива новый размер вектора превышает его текущую вместимость, создайте новый массив с нужной вместимостью, скопируйте в него прежнее содержимое и заполните остальные элементы значением по умолчанию. Затем старый массив можно удалить и использовать копию. После этого не забудьте обновить размер и вместимость вектора.
Если при увеличении размера массива новый размер вектора не превышает его вместимость, заполните добавленные элементы значением по умолчанию для типа Type.
При уменьшении размера вектора просто уменьшите его размер.
Примените алгоритмы std::copy и std::fill для копирования элементов массива и заполнения их некоторым значением.
В методе Clear достаточно обнулить размер массива.
