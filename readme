Задание
Задание
Создайте вектор, который не использует память из кучи, а хранит все свои объекты в стеке. 
Вы знакомы с контейнером array, который поможет решить эту задачу. Реализуйте интерфейс вектора поверх него: разработайте шаблон класса template <typename T, size_t N> StackVector<T, N>, где T — тип элемента вектора, а N — его максимальная вместимость. Класс StackVector должен иметь следующий интерфейс:
template <typename T, size_t N>
class StackVector {
public:
    explicit StackVector(size_t a_size = 0);

    T& operator[](size_t index);
    const T& operator[](size_t index) const;

    ??? begin();
    ??? end();
    ??? begin() const;
    ??? end() const;

    size_t Size() const;
    size_t Capacity() const;

    void PushBack(const T& value);
    T PopBack();
}; 
Метод Capacity должен возвращать вместимость вектора — то есть количество объектов, которое в него может поместиться.
Метод Size должен возвращать текущее количество объектов в векторе.
Конструктор принимает размер вектора — по аналогии со стандартным вектором. Если аргумент конструктора больше вместимости вектора, конструктор должен выбрасывать исключение invalid_argument.
Методы begin/end должны возвращать итераторы на начало и текущий конец вектора. Их тип не указан, выберите его самостоятельно.
Метод PushBack добавляет новый элемент в конец вектора. Если текущий размер вектора равен его вместимости, метод PushBack должен выбрасывать стандартное исключение overflow_error.
Метод PopBack уменьшает размер вектора на один и возвращает элемент вектора, который был последним. Если вектор пуст, метод PopBack должен выбрасывать стандартное исключение underflow_error.
Интерфейс класса StackVector описан в файле stack_vector.h. Часть требований к нему сформулирована в виде юнит-тестов в файле main.cpp.
Файл main.cpp содержит бенчмарк, который демонстрирует преимущество StackVector перед обычным вектором. Этот бенчмарк моделирует ситуацию, когда мы считываем из потока количество объектов N, а затем добавляем в вектор N объектов. Для этого используем метод push_back. Тестовые данные разложены в vector<vector<int>>, чтобы исключить из бенчмарка время, нужное на парсинг. Когда реализуете шаблон StackVector, сравните его производительность с вектором.

Подсказка:
Обратите внимание, как отличается поведение метода PushBack в классе StackVector от метода PushBack в классе SimpleVector,
который вы реализовывали в предыдущем спринте. SimpleVector::PushBack выделял дополнительную память в куче, если размер вектора оказывался равен ёмкости. 
В случае с классом StackVector нужно на этапе компиляции задать максимальную ёмкость вектора. Если она исчерпается, взять память будет неоткуда, 
и выбросится исключение. В этом недостаток реализации вектора в стеке по сравнению с обычным вектором.
