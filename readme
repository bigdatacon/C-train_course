Подсказка : 
unordered_map очень похож на обычный map, он поддерживает те же методы: erase, clear, at.
Для получения количества секунд из Duration можно применить такую конструкцию: chrono::duration_cast<chrono::seconds>(duration).count(). Затем для получения стоимости нужно умножить количество секунд на стоимость секунды.
Можете складывать объекты типа Duration.


Задание
Задание 2
Совет директоров бизнес-центра «Ассоциарий» решил изменить порядок оплаты парковки. Теперь плата взимается за количество проведённых на стоянке секунд. Автовладелец должен иметь возможность в любой момент времени проверить, сколько начислено за парковку его автомобиля в текущий момент, учитывая в том числе незавершённую парковку.
В этом задании вам пригодится хешер номеров из предыдущего задания.
Разработайте класс Parking, имеющий следующие методы:
Конструктор Parking(int cost_per_second) — указывается стоимость одной секунды парковки.
void Park(VehiclePlate car) — запарковать машину с указанным номером. В случае если машина с указанным номером уже запаркована, сгенерируйте исключение ParkingException (этот класс есть в заготовке).
void Withdraw(const VehiclePlate& car) — забрать машину с указанным номером. В случае если указанный автомобиль не был запаркован, сгенерируйте исключение ParkingException.
int64_t GetCurrentBill(const VehiclePlate& car) const — получить счёт за конкретный автомобиль. Для вычисления стоимости умножьте количество проведённых автомобилем на парковке секунд на число cost_per_second_. Должны быть учтены все завершённые парковки. Если автомобиль запаркован на момент вызова, то в сумму должна быть включена также стоимость его незавершённой парковки на данный момент. Если номера нет в системе, верните ноль.
unordered_map<VehiclePlate, int64_t, VehiclePlateHasher> EndPeriodAndGetBills() — завершить расчётный период. Вернуть счета за все автомобили в одном ассоциативном контейнере. Нулевые счета включать в расчёт не нужно. Кроме того, вам нужно обнулить все счета. Если какие-нибудь автомобили запаркованы в момент вызова, они должны остаться на парковке, но отсчёт времени для них начинается заново.
Для определения времени класс Parking использует шаблонный параметр class Clock. Узнать текущее время можно, вызвав статический метод Clock::now(). Он возвращает объект типа Clock::time_point. Длительность имеет тип Clock::duration, это разность двух объектов типа Clock::time_point. Рекомендуется использовать для этих типов псевдонимы TimePoint и Duration, которые объявлены в заготовке кода. Получить из Duration секунды можно функцией duration_cast, которую вы проходили в теме о профилировке.
Во всех методах этого класса, которые зависят от текущего момента, время нужно измерить один раз вызовом Clock::now в любой момент во время выполнения метода.
В заготовке кода вы найдёте класс TestClock — часы, упрощающие тестирование кода. Если указать их в качестве шаблонного параметра, время операции вы будете задавать явно статической функцией TestClock::SetNow. Пример — в заготовке кода.
В заготовке кода также есть методы GetNowParked и GetCurrentDurations. Они возвращают внутренние контейнеры класса Parking. Не меняйте их, иначе программа не пройдёт тестирование.
Ограничения
Для хранения открытых и завершённых парковок используйте два контейнера unordered_map, которые представлены в заготовке кода. Не меняйте методы получения контейнеров, класс VehiclePlate, не добавляйте в класс Parking новых полей.
Хешер номеров должен удовлетворять всем требованиям предыдущей задачи.
Пример
Пример приведён в заготовке кода. Там же реализованы часы, которые можно использовать для тестирования. Они показывают столько времени, сколько задал пользователь явно.
Как будет тестироваться ваш код
Мы проверим:
корректность реализации методов класса Parking;
то, что хешер номеров учитывает все компоненты номера автомобиля;
то, что вы не меняли класс VehiclePlate;
то, что вы не изменили поля класса Parking и не использовали map;
выбрасывание исключения ParkingException при некорректных операциях;
то, что в контейнерах now_parked_ и complete_parks_ всегда корректные данные.
