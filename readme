Подсказка : 
Если ваша программа зацикливается, поймайте значения границ, на которых это происходит — наверняка понадобится отдельно обработать крайний случай. 
Между созданием future и вызовом get для future должны выполняться некоторые сложные вычисления.


Задание
Вспомните схему обычного бинарного поиска. На каждой итерации цикла есть полуинтервал элементов [left, right), в котором  ищется value. Пусть middle — середина этого полуинтервала. Если *middle < value, надо продолжать поиск справа от middle, иначе — слева.
Примените ту же идею, но с разбиением полуинтервала на три части. Выберите middle_left и middle_right, сравните элементы под ними с value параллельно и на основании полученных результатов выберите, в какой из третей продолжать поиск.
Базовая версия LowerBound — последовательная и с разбиением на две части — уже написана за вас. Тем не менее, вам понадобится очень внимательное тестирование, чтобы отловить все неприятные крайние случаи.
Что отправлять на проверку
Отправьте cpp-файл, содержащий три версии шаблонной функции LowerBound:
без ExecutionPolicy,
с execution::seq,
с execution::par.
А также нужные для их работы подключения библиотек и другие функции.  Ваша программа должна содержать подстроку async. Функция main будет проигнорирована при тестировании.
Как будет тестироваться ваш код
Правильность работы функции будет проверена юнит-тестами.
Производительность параллельной версии будет проверена так. Дан отсортированный вектор из 10 объектов некоторого класса Heavy. Для этого класса определён оператор сравнения, и сравнение занимает относительно большое время. Измерим время, за которое будут обработаны 100 запросов LowerBound к этому вектору.
Время работы многопоточной версии вашей функции должно быть по крайней мере на 25% меньше, чем у версии из заготовки кода.
Также это время должно быть по крайней мере на 25% меньше, чем у вашей однопоточной версии в обоих вариантах вызова.
Бенчмарк для самопроверки разработайте самостоятельно.
