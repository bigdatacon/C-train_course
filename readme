Подсказка : 
Если у узла есть правое поддерево, ищите следующий в нём
Вам пригодится функция begin для поиска следующего в правом поддереве
Если справа ничего нет, идите в родителя. Родитель будет следующим, если вы пришли в него из левого поддерева. А если из правого, то отправляйтесь ещё выше
  


Задание
Задание
Реализуйте операцию передвижения вперёд для итератора в дереве поиска.
Теперь узел дерева содержит указатель на родительский элемент, то есть элемент над ним:
template <typename T>
struct TreeNode {
    T value;
    TreeNode* parent = nullptr;
    TreeNode* left = nullptr;
    TreeNode* right = nullptr;
}; 
Реализуйте функцию template <typename T> TreeNode<T>* begin(TreeNode<T>* node) для поиска начального узла в дереве, а также функцию template <typename T> TreeNode<T>* next(TreeNode<T>* node) для поиска следующего по величине узла.
Если узел последний, next должна вернуть nullptr.
Ограничения
Реализация next должна быть эффективной и проходить ровно столько узлов дерева, сколько нужно пройти до требуемой позиции. Сложность функции next должна быть амортизированной O(1)O(1).
Содержимое узлов учитывать не нужно.
Пример
В заготовке реализована функция N для создания дерева. В main создаётся дерево из примера к заданию к прошлому уроку:
int main() {
    using T = TreeNode<int>;

    T* root = N(6, N(4, N(3), N(5)), N(8, N(7)));
    cout << root << endl;

    T* iter = begin(root);

    while (iter) {
        cout << iter->value << " "s;
        iter = next(iter);
    }
    cout << endl;

    DeleteTree(root);
} 
Вывод должен быть следующий:
( 6 ( 4 ( 3 )  ( 5 )  )  ( 8 ( 7 ) * )  )
3 4 5 6 7 8 
Как будет тестироваться ваш код
Проверим, что 
begin правильно находит начало дерева;
next возвращает nullptr для последнего узла;
next правильно проходит всё дерево;
next работает эффективно и не делает лишних действий.
