Подсказка : 
Вам пригодится вспомогательная функция, проверяющая, что все элементы дерева находятся в некотором интервале [min, max], причём min и max могут быть не определены.
Значения min и max можно представить в виде optional или в виде указателей, задающих верхнюю и нижнюю границы. Указатель может быть равен nullptr, если граница не задана. В случае использования указателей функция проверки может быть рекурсивной и иметь такую сигнатуру:

cpp
  /* 
  Возвращает true, если узел node и его дочерние элементы находятся в диапазоне [min, max]
  */
  template <typename T>
  bool CheckTreeProperty(const TreeNode<T>* node, const T* min, const T* max);
  
Функция проверки всего дерева с корневым узлом node сводится к одной строчке:

cpp
  return CheckTreeProperty<T>(node, nullptr, nullptr);
  


Задание
Задание
Решение этого задания пригодится вам в дальнейшем. Сохраните его.
Директор «‎Ассоциария»‎ любит порядок. Скоро Новый год, и директор поручил сотрудникам нарядить ёлку его любимыми игрушками. Директор любит свои игрушки и периодически подходит к ёлке удостовериться, что сотрудники ни одну из них не разбили. Чтобы игрушки проще было искать, он ввёл порядок — пронумеровал игрушки — и распорядился организовать ёлку в виде двоичного дерева поиска.
Чтобы убедиться, что сотрудники справились со своей задачей, реализуйте функцию template <typename T> bool CheckTreeProperty(const TreeNode<T>* node) для проверки свойства дерева поиска: элементы в левом поддереве должны быть меньше значения в узле, а элементы правого — больше.
Узел дерева задаётся такой структурой:
template <typename T>
struct TreeNode {
    T value;
    TreeNode* left;
    TreeNode* right;
}; 
Указатели на отсутствующие поддеревья равны nullptr.
Ограничения
Пройдите по дереву не более одного раза. Допускается рекурсивная реализация.
Пример
Пример — в заготовке кода. В нём используются такие деревья:
image
Как будет тестироваться ваш код
Проверим, что программа правильно решает задачу.
Проверим, что программа эффективно решает задачу.
