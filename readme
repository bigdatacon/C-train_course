Задание
Задание 1
У вас есть каркас шаблонного класса ScopedPtr. Это умный указатель, в котором частично реализован такой функционал:
Конструктор по умолчанию инициализирует указатель нулевым значением;
Заготовка метода GetRawPtr. Метод возвращает адрес объекта, на который ссылается умный указатель;
Заготовка конвертирующего конструктора для создания ScopedPtr из сырого указателя;
Удалённый конструктор копирования. В этом случае создать копию умного указателя будет нельзя. Как следствие, не будет проблем, когда два умных указателя владеют одним объектом.
template <typename T>
class ScopedPtr {
public:
    ScopedPtr() = default;
    explicit ScopedPtr(T* raw_ptr) noexcept {...}
    ScopedPtr(const ScopedPtr&) = delete;
    ~ScopedPtr() {...}
    T* GetRawPtr() const noexcept {...}
    T* Release() noexcept {...}

private:
    T* ptr_ = nullptr;
}; 
Объект класса ScopedPtr<T> может находиться в двух состояниях: владеть объектом типа T или не владеть. При этом должны выполняться следующие правила:
Конструктор без параметров создаёт умный указатель, не владеющий объектом.
Конструктор ScopedPtr(T* raw_ptr) создаёт умный указатель, который владеет объектом, если и только если переданный указатель не был равен nullptr.
Метод GetRawPtr не влияет на владение.
Метод Release отменяет владение, если оно было.
Цель умного указателя — удалить объект, которым он владеет. Он должен делать это в своём деструкторе, который вам предстоит реализовать вместе с недостающими методами.
Проверки в заготовке кода упростят реализацию конструкторов и деструкторов.
Требования
Реализуйте недостающие методы класса ScopedPtr:
Недостающий код конструктора ScopedPtr из «сырого»‎ указателя на объект в динамической памяти. Созданный ScopedPtr должен владеть переданным объектом. Допустимо значение указателя nullptr. В этом случае владения не возникает.
Тело метода GetRawPtr.
Удаление объекта, которым владеет ScopedPtr, в деструкторе.
Тело метода Release.
Ограничения
Сохраните сигнатуры всех публичных методов класса ScopedPtr неизменными, чтобы код скомпилировался без ошибок.
Что отправлять на проверку
Загрузите в тренажёр только код с шаблоном класса ScopedPtr и нужными для его работы директивами #include. Функция main при проверке учитываться не будет.
Как будет тестироваться ваш код
Шаблон класса ScopedPtr будет протестирован кодом, подобным тому, что есть в функции main.
Передаваемые в конструктор указатели ссылаются на объект, созданный в куче с использованием операции new, либо равны nullptr.


Подсказка : 
Используйте проверки в функции main из заготовки кода.
В конвертирующем конструкторе сохраните переданный «‎сырой»‎ указатель в поле ptr_.
В методе GetRawPtr верните текущее значение ptr_.
Удалите объект, на который ссылается поле ptr_ в деструкторе.
В методе Release обнулите поле ptr_, не удаляя сам объект, и верните прежнее значение поля.

