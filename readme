Подсказка : 
unordered_map по использованию не отличается от map, только не забудьте указать третий шаблонный параметр — хешер.
В класс VehiclePlateHasher добавьте поле класса hash<string> hasher_. Чтобы вычислить хеш строки, его можно использовать так: hasher_("abc"s). Примените хешер к строковому представлению номера для вычисления его хеша.


Задание
Задание 1
Автостоянка у бизнес-центра «Ассоциарий»‎ взимает плату с владельцев автомобилей за количество парковок в определённом месяце. Реализуйте класс ParkingCounter, который будет считать автомобили. Класс должен иметь три метода:
void Park(VehiclePlate car), который регистрирует парковку автомобиля;
int GetCount(const VehiclePlate& car) const, который вычисляет количество парковок определённого автомобиля;
auto& GetAllData() const, который возвращает ассоциативный контейнер, содержащий количество парковок по каждому номеру.
Храните количества парковок в контейнере unordered_map. Учитывайте, что для номеров, которые не добавлены ни разу, функция GetCount должна вернуть 0.
Модифицируйте класс VehiclePlateHasher, чтобы он учитывал все данные номера. Рекомендуется создать для хеширования объект типа hash<string> и выдавать хеш строкового представления номера, полученного методом ToString().
Скопируйте реализованный хешер, он вам пригодится для следующего задания.
Ограничения
Для хранения открытых парковок и счетов на данный момент используйте контейнер unordered_map. Не меняйте метод GetAllData.
Хешер должен учитывать все данные номера.
Не меняйте класс VehiclePlate.
Не используйте map и set.
Пример
ParkingCounter parking;

parking.Park({'B', 'H', 840, 'E', 99});
parking.Park({'O', 'K', 942, 'K', 78});
parking.Park({'O', 'K', 942, 'K', 78});
parking.Park({'O', 'K', 942, 'K', 78});
parking.Park({'O', 'K', 942, 'K', 78});
parking.Park({'H', 'E', 968, 'C', 79});
parking.Park({'T', 'A', 326, 'X', 83});
parking.Park({'H', 'H', 831, 'P', 116});
parking.Park({'A', 'P', 831, 'Y', 99});
parking.Park({'P', 'M', 884, 'K', 23});
parking.Park({'O', 'C', 34, 'P', 24});
parking.Park({'M', 'Y', 831, 'M', 43});
parking.Park({'B', 'P', 831, 'M', 79});
parking.Park({'O', 'K', 942, 'K', 78});
parking.Park({'K', 'T', 478, 'P', 49});
parking.Park({'X', 'P', 850, 'A', 50});

assert(parking.GetCount({'O', 'K', 942, 'K', 78}) == 5);
assert(parking.GetCount({'A', 'B', 111, 'C', 99}) == 0);

for(auto& [plate, count] : parking.GetAllData()) {
    cout << plate << " "s << count << endl;
} 
Возможный вывод:
XP850A50 1
TA326X83 1
HE968C79 1
KT478P49 1
AP831Y99 1
OK942K78 5
BH840E99 1
BP831M79 1
HH831P116 1
MY831M43 1
PM884K23 1
OC034P24 1 
