Подсказка : 
Начните с написания шаблонной функции ForEach, принимающей произвольные ExecutionPolicy, контейнер и функцию и вызывающей for_each. Добавьте версию от двух параметров, вызывающую предыдущую с execution::seq.
Теперь самый простой способ — добавить в основную версию ветвление следующего вида: «если тип ExecutionPolicy — это execution::par и итераторы контейнера не обладают произвольным доступом, вызвать свою версию». Проблема в том, что в C++ типы — это не объекты: их нельзя сравнивать на == и передавать их в функции. Зато типы могут быть параметрами шаблонов, поэтому будем использовать шаблонную магию из библиотек <type_traits> и <iterator>.
Чтобы проверить, что два типа совпадают, используйте is_same_v: is_same_v<ExecutionPolicy, execution::sequenced_policy>. Если что-нибудь не работает, вероятно, тип ExecutionPolicy отличается от нужного лишь константностью или наличием ссылки. В этом случае поможет обернуть его в decay_t: is_same_v<decay_t<ExecutionPolicy>, execution::sequenced_policy>.
Здесь is_same_v, это шаблонная булевская переменная, так что при подстановке в неё двух типов выражение is_same_v<T, U> имеет тип bool и может участвовать в логических выражениях.
Тип итератора для контейнера типа ForwardRange можно получить с помощью выражения typename ForwardRange::iterator. В реальной жизни это не всегда так, и в авторском решении вы увидите более правильный подход.
Получить категорию итератора типа It можно, использовав выражение typename iterator_traits<It>::iterator_category.
Категория итератора — это некоторый тип, объекты которого вам точно не понадобится создавать. Вам нужен random_access_iterator_tag.
Условие из этих кирпичиков можно поместить в оператор if: тогда при каждом вызове функции оно будет проверяться. Но поскольку результат


Задание
Победить в производительности стандартный алгоритм, пусть и в не совсем честной борьбе — большое достижение. Но чтобы вашу функцию можно было использовать в самых разных сценариях, хочется сделать её умнее. Пусть ваша версия вызывается только тогда, когда пользователь передал execution::par и контейнер без произвольного доступа. В остальных случаях нужно вызвать стандартный алгоритм.
Это непростая задача, и ничему подобному мы вас не учили. Но в жизни случается всякое. Поэтому поэкспериментируйте и попробуйте найти ответ сами. А если не выйдёт, в подсказке вас ждёт описание самой короткой дороги к успеху. После сдачи задания вы сможете посмотреть на решение с использованием самых свежих возможностей C++20.
Ограничения
Гарантируется, что тип итератора передаваемого в функцию контейнера типа C можно получить, используя выражение typename C::iterator. В вашу функцию не будут передаваться контейнеры, итераторы которых не однонаправленные. И без этого непросто.
Что отправлять на проверку
cpp-файл, содержащий функцию ForEach, а также необходимые для её работы подключения библиотек, другие классы и функции. Функция main будет проигнорирована при тестировании.
Как будет тестироваться ваш код
В тестах ваша функция будет вызвана с различными контейнерами и с различными значениями execution_policy — см. пример выше. Для каждой комбинации параметров будет измерено время работы вашей функции, а также время работы «стандартной» версии на основе std::for_each.
При работе с контейнером без произвольного доступа к элементам и с политикой execution::par ваша версия должна быть эффективнее стандартной минимум на 40%.
Во всех остальных случаях проверяется, что по времени выполнения ваша функция не отличается от стандартной более чем на 10% в любую сторону.
Также в каждом из тестов результаты работы вашей и стандартной функции проверяются на совпадение.
