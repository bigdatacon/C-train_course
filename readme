Задание:
Сигнатура метода Reserve:
void Reserve(size_t new_capacity); 
Reserve задает ёмкость вектора. Этот метод повышает эффективность кода в случае, когда пользователь заранее знает хотя бы приблизительное количество элементов в векторе. Reserve сразу выделяет нужное количество памяти. При добавлении новых элементов в вектор копирование будет происходить или значительно реже или совсем не будет.
Если new_capacity больше текущей capacity, память должна быть перевыделена, а элементы вектора скопированы в новый отрезок памяти.
Кроме этого реализуйте возможность вызвать конструктор SimpleVector, который будет сразу резервировать нужное количество памяти. Пример вызова ниже.
Пример использования
#include "simple_vector.h"

#include <cassert>
#include <iostream>

using namespace std;

void TestReserveConstructor() {
    cout << "TestReserveConstructor"s << endl;
    SimpleVector<int> v(Reserve(5));
    assert(v.GetCapacity() == 5);
    assert(v.IsEmpty());
    cout << "Done!"s << endl;
}

void TestReserveMethod() {
    cout << "TestReserveMethod"s << endl;
    SimpleVector<int> v;
    // зарезервируем 5 мест в векторе
    v.Reserve(5);
    assert(v.GetCapacity() == 5);
    assert(v.IsEmpty());

    // попытаемся уменьшить capacity до 1
    v.Reserve(1);
    // capacity должно остаться прежним
    assert(v.GetCapacity() == 5);
    // поместим 10 элементов в вектор
    for (int i = 0; i < 10; ++i) {
        v.PushBack(i);
    }
    assert(v.GetSize() == 10);
    // увеличим capacity до 100
    v.Reserve(100);
    // проверим, что размер не поменялся
    assert(v.GetSize() == 10);
    assert(v.GetCapacity() == 100);
    // проверим, что элементы на месте
    for (int i = 0; i < 10; ++i) {
        assert(v[i] == i);
    }
    cout << "Done!"s << endl;
}

int main() {
    TestReserveConstructor();
    TestReserveMethod();
}

ПОДСКАЗКА: 
Не забудьте обновить указатель на начало вектора и текущую ёмкость. Для реализации конструктора с резервированием вам понадобится дополнительный класс-обёртка, чтобы компилятор мог разобраться и вызвать правильный конструктор. Этот конструктор должен принимать по значению объект этого класса-обёртки. Тогда функция (не метод!) будет иметь следующую сигнатуру:
ReserveProxyObj Reserve(size_t capacity_to_reserve) {
    return ReserveProxyObj(capacity_to_reserve);
}; 
