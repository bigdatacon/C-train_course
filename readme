Подсказка : 
Призовите на помощь lock_guard<mutex>.


Задание
Задание
Когда нет синхронизации доступа нескольких потоков к одним и тем же данным, это может фатально сказаться на работе программы. Поэтому важно не забывать захватывать мьютекс при обращении к разделяемым данным. Но бывают большие проекты, где доступ к общим данным осуществляется из множества мест в коде. При внесении очередных правок забыть о мьютексе легко.
Чтобы защититься от этой проблемы, можно написать специальную обёртку над данными, которая будет предоставлять к ним доступ только под мьютексом. Разработайте обёртку — шаблон класса Synchronized с таким интерфейсом:
template <typename T>
class Synchronized {
public:
      explicit Synchronized(T initial = T());
    
      struct Access {
            V& ref_to_value;
        // ...
      };
    
      Access GetAccess();
private:
      T value_;
}; 
Тип Access должен быть структурой, в которой есть поле T& ref_to_value, ссылающееся на поле value_ класса Synchronized<T>. Объект класса Access должен вести себя аналогично классу lock_guard<mutex>: захватывать мьютекс в своём конструкторе и освобождать в деструкторе. Пример:
Synchronized<int> s_int;
{
      auto access = s_int.GetAccess();
      // Критическая секция начинается отсюда и продолжается до конца блока
      access.ref_to_value = 5;
}
ASSERT_EQUAL(s_int.GetAccess().ref_to_value, 5); 
Можно и даже нужно добавлять необходимые поля в класс Access и шаблон Synchronized. Более подробные примеры использования шаблона Synchronized смотрите в заготовке кода.
Как видите, единственный способ получить доступ к полю value_ класса Synchronized<T> — это обратиться к полю ref_to_value класса Access, который гарантирует, что этот доступ осуществляется под мьютексом. Таким образом, если разделяемые данные обернуть в шаблон Synchronized, вы никогда не забудете захватить мьютекс при обращении к ним.
Ограничения
Тип T гарантированно имеет конструктор по умолчанию, но может не иметь конструктора копирования.
Что отправлять на проверку
cpp-файл, содержащий шаблонный класс Synchronized, а также необходимые для его работы подключения библиотек и другие функции. Функция main будет проигнорирована при тестировании.
Как будет тестироваться ваш код
По аналогии с примером в заготовке кода будет проверено, что структура Access действительно обеспечивает синхронизацию действий между потоками.
