Условие задачи
Задание
Задание 3
А теперь по-настоящему серьёзный вызов: Ханойская башня — популярная головоломка XIX века по версии Википедии.
Даны три стержня. На один из них нанизаны восемь колец разного размера. Кольца лежат меньшее на большем. Задача в том, чтобы перенести пирамиду из восьми колец на другой стержень за наименьшее число ходов. За один раз можно переносить только одно кольцо, причём нельзя класть большее кольцо на меньшее.
Решите эту задачу рекурсивным методом. Напишите функцию SolveHanoi, которая принимает ссылку на вектор из трёх стержней-башен. На первой башне надето определённое количество дисков — не обязательно восемь, как в классической задаче. Количество можно узнать, воспользовавшись методом GetDisksNum. Класс Tower уже имеет некоторые методы или части методов. Другие методы вы можете дописывать так, как вам нужно для решения. В результате работы функции SolveHanoi все диски в правильном порядке должны оказаться на третьей башне.
Чтобы решить задачу, вспомните, что во все методы класса неявно передаётся указатель на объект this. А если применить оператор *, можно получить доступ к самому элементу. Чтобы освежить в памяти детали, вернитесь к уроку «Перегрузка операций присваивания». 
Пример использования
int main() {
    int towers_num = 3;
    int disks_num = 3;
    vector<Tower> towers;
    // добавим в вектор три пустые башни
    for (int i = 0; i < towers_num; ++i) {
        towers.push_back(0);
    }
    // добавим на первую башню три кольца
    towers[0].SetDisks(disks_num);
    SolveHanoi(towers);
} 
Пример результата работы
Ниже не пример вывода на экран — в задаче он не требуется. Это пример того, что должно произойти с вектором башен после вызова SolveHanoi:
Вектор башен до перемещения:
Башня 1: 3 2 1
Башня 2: 0 0 0
Башня 3: 0 0 0
Вектор башен после перемещения:
Башня 1: 0 0 0
Башня 2: 0 0 0
Башня 3: 3 2 1 


Подсказка: 
Какие параметры принимает функция? Здесь это самое интересное. Функция SolveHanoi сама по себе рекурсивной не будет. Используйте другую. Вам пригодится это:
 // disks_num - количество перемещаемых дисков
 // destination - конечная башня для перемещения
 // buffer - башня, которую нужно использовать в качестве буфера для дисков
 void MoveDisks(int disks_num, Tower& destination, Tower& buffer) {
     if (// условие выхода ещё не выполнено) {
         // действия из шага рекурсии
     }
 }
 
 void SolveHanoi(vector<Tower>& towers) {
     int disks_num = towers[0].GetDisksNum();
     // запускаем рекурсию
     // просим переложить все диски на последнюю башню
     // с использованием средней башни как буфера
     towers[0].MoveDisks(disks_num, towers[2], towers[1]);
 }
  
Какие действия должна совершить функция на каждом шаге? Препарируйте задачу. Порисуйте диски, найдите повторяющийся паттерн. Скорее всего, он будет состоять из нескольких действий.
Каково условие завершения? Всё просто — как только дисков не осталось, не нужно ничего больше перемещать.

	//4:3:2:1   0   0 
	//4:3:2    1   0
	//4:3   1    2

	//4:3  0  2:1
	//4   3   2:1   // точка при которой на source 1 диск 
	 
	//4:1  3  2
	//4:1  3:2  
	//4  3:2:1  // точка при которой все кроме 1 на buffer

	// 0  3:2:1 4
	//0  3:2   4:1
	//2  3    4 :1
	//2:1  3  4
	//2:1  0  4:3
	//2   1   4:3
	//0   1   4:3:2
	//0   0   4:3:2:1



	//5:4:3:2:1   0   0 
	//5:4:3:2    1   0
	//5:4:3   1    2
	//5:4:3  0  2:1  - первая пара раскидывается только в начале когда на buffer и distination ничего нет, далее по 1 диску
	 
	
	//5:4   3   2:1   // точка когда раскидывается следующий диск с source 
	//5:4:1 3   2
	// 5:4:1  3:2   0
	//5:4   3:2:1   0
