Подсказка : 
Минимизируйте критическую область вокруг вставки в конец вектора. Вынесите из неё не только проверку условия, но и копирование нового элемента.

Задание
Задание
Как вы, возможно, помните, алгоритм copy_if фильтрует элементы из данного диапазона и сохраняет подходящие в указанный выходной итератор, сохраняя их исходный порядок. Ваша задача — ускорить copy_if за счёт параллельности и отказа от требования сохранения порядка элементов.
Напишите шаблонную функцию CopyIfUnordered, которая:
принимает контейнер элементов и предикат — функцию, принимающую элемент и возвращающую bool;
возвращает вектор элементов, для которых предикат вернул true;
порядок элементов в итоговом векторе не имеет значения, но каждый элемент, удовлетворяющий предикату, должен присутствовать в результате ровно столько же раз, сколько в исходном контейнере.
В заготовке кода вам дана последовательная версия этой функции. Ускорьте её.
Ограничения
Гарантируется, что для типа Container можно получить тип хранящихся в нём объектов, используя выражение typename Container::value_type. Эти элементы имеют конструктор по умолчанию и конструктор копирования.
Что отправлять на проверку
cpp-файл, содержащий шаблонную функцию CopyIfUnordered, а также нужные для её работы подключения библиотек и другие функции. Функция main будет проигнорирована при тестировании.
Как будет тестироваться ваш код
Помимо корректности будет протестирована скорость работы функции.
Ваша функция должна быть эффективнее последовательного решения из заготовки кода минимум на 40% при следующих условиях:
контейнер — вектор и содержит 50 000 строк длиной до 3 000 символов;
фильтрующий предикат имеет линейную по длине строки сложность.
Вы можете ориентироваться на бенчмарк, данный в заготовке кода.
