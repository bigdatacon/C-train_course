Задание
Задание
Попрактикуйтесь использовать константные указатели на примере программы, которая ведёт учёт кошек. В ней кошки представлены структурой Cat, задающей имя, пол, породу и возраст:
// Породы кошек
enum class CatBreed {
    Bengal,
    Balinese,
    Persian,
    Siamese,
    Siberian,
    Sphynx,
};

// Пол
enum class Gender {
    Male,
    Female,
};

struct Cat {
    string name;
    Gender gender;
    CatBreed breed;
    int age;
}; 
Для хранения кошек используется контейнер vector:
int main() {
    const vector<Cat> cats = {
        {"Tom"s, Gender::Male, CatBreed::Bengal, 2},
        {"Leo"s, Gender::Male, CatBreed::Siberian, 3},
        {"Luna"s, Gender::Female, CatBreed::Siamese, 1},
        {"Charlie"s, Gender::Male, CatBreed::Balinese, 7},
        {"Ginger"s, Gender::Female, CatBreed::Sphynx, 5},
        {"Tom"s, Gender::Male, CatBreed::Siamese, 2},
    };
    ...
} 
Требуется создать в программе несколько одновременно существующих представлений этой коллекции, отсортированных по разным критериям:
По породе и имени. Кошки одинаковой породы сортируются по имени.
По полу и породе.
Простейшее решение — создать несколько копий вектора кошек и отсортировать их по заданным критериям. Основной недостаток решения — избыточное потребление памяти. Каждая кошка будет храниться в нескольких экземплярах со всеми своими данными. Представьте, что вам пришлось бы клонировать оригинальный набор кошек, а потом отсортировать копию каждого набора. Слишком много кошек!
Более эффективно хранить каждую кошку в единственном экземпляре в контейнере cats. Отсортированное представление контейнера cats можно задать в виде вектора указателей, которые ссылаются на кошек из cats и отсортированы как надо. Для хранения указателя нужно в несколько раз меньше памяти, чем для хранения данных о кошке. Такое решение аналогично сортировке листков бумаги с адресами этих замечательных животных.
image

Два индекса используют одни и те же данные
Требования
Напишите
шаблонную функцию GetSortedCats, которая принимает константную ссылку на массив кошек,
функцию-компаратор, которая проверяет кошек на упорядоченность.
GetSortedCats должна вернуть контейнер vector<const Cat*>, содержащий указатели на элементы вектора кошек. Для сортировки указателей используйте переданную функцию-компаратор:
// Возвращает массив указателей на элементы вектора cats, отсортированные с использованием
// компаратора comp. Компаратор comp - функция, принимающая два аргумента типа const Cat&
// и возвращающая true, если значения упорядочены, и false в ином случае
template <typename Comparator>
vector<const Cat*> GetSortedCats(const vector<Cat>& cats, const Comparator& comp) {
    ...
}

int main() {
    const vector<Cat> cats = { ... };

    auto sorted_cats = GetSortedCats(cats, [](const Cat& lhs, const Cat& rhs) {
        // Сравниваем кошек по породе и имени
        return tie(lhs.breed, lhs.name) < tie(rhs.breed, rhs.name);
    });
    // sorted_cats - вектор указателей на кошек, отсортированных по кличке и имени
    ...
} 
Чтобы вывести информацию о кошках из массива указателей, напишите функцию PrintCatPointerValues: 
// Выводит в поток out кошек, на которых ссылаются указатели вектора cat_pointers.
// Пример вывода:
// {{Tom, male, breed: Bengal, age:2}, {Charlie, male, breed: Balinese, age:7}}
void PrintCatPointerValues(const vector<const Cat*>& cat_pointers, ostream& out) {
    ...
}

int main() {
    ...
    auto sorted_cats = GetSortedCats(...);
    PrintCatPointerValues(sorted_cats, cout);
    ...
} 
В заготовке кода есть готовые операции вывода кошек в поток.
Ограничения
Вектор кошек, передаваемый в функцию GetSortedCats, может содержать от 0 до 1000000 кошек. Клички кошек могут содержать буквы английского алфавита в разном регистре и пробелы, например: “Cat in Boots”.
Что отправлять на проверку
Загрузите в тренажёр код программы без функции main. Функция main, если она будет загружена в тренажёр, будет заменена на версию из тренажёра.
Как будет тестироваться ваш код
Функции GetSortedCats и PrintCatPointerValues будут протестированы кодом, подобным тому, что сейчас находится в функции main.

Подсказка: 

Чтобы получить отсортированное представление, создайте вектор указателей, ссылающихся на элементы оригинального контейнера кошек. Затем отсортируйте этот вектор как нужно. Программа должна сортировать указатели, сравнивая их значения, а не их адреса. Пример:
#include <algorithm>
#include <cassert>
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> items = {5, 2, 3, 4};
    vector<const int*> item_pointers;
    // Перебирать элементы вектора здесь следует по константной ссылке,
    // а не по значению.
    // В противном случае item_pointers будут хранить адреса объектов,
    // область видимости которых ограничена телом цикла
    for (const int& item : items) {
        item_pointers.push_back(&item);
    }

    // сортируем указатели в порядке убывания чисел, на которые они ссылаются.
    sort(item_pointers.begin(), item_pointers.end(), [](const int* lhs, const int* rhs) {
        // Чтобы сравнить значения, надо разыменовать указатели
        return *lhs > *rhs;
    });

    for (const int* item_ptr : item_pointers) {
        cout << *item_ptr << ", "s;
    }
} 

