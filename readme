Подсказка : 
Читайте слова из потока в переменную string word таким образом: while (text >> word)
Создайте ассоциативный контейнер, который будет хранить слова по хешу
Подойдёт unordered_map<size_t, unordered_set<string>>
Если для хеша есть слово, и вы нашли другое, возникает коллизия
Где можно используйте move для слов


Задание
Задание 1
Реализуйте функцию, которая будет определять количество коллизий в тексте:
template <typename Hash>
int FindCollisions(const Hash& hasher, istream& text); 
Хешер будет передан одним из параметров. Текст нужно читать из потока по словам. Коллизией считаем ситуацию, когда прочитано слово, которое не встречалось ранее, и его хеш совпал с хешем одного из предыдущих слов.
Искать границы слов не нужно. Считайте, что в тексте они уже разделены пробелами, и доверьтесь операции >>.
Эту программу можно будет использовать для проверки качества строковой хеш-функции.
Пример
#include <iostream>
#include <sstream>
#include <string>

using namespace std;

// ваша реализация функции FindCollisions

struct DummyHash {
    size_t operator()(const string&) const {
        return 42;
    }
};

int main() {
    DummyHash dummy_hash;
    hash<string> good_hash;

    {
        istringstream stream("I love C++"s);
        cout << FindCollisions(dummy_hash, stream) << endl;
    }
    {
        istringstream stream("I love C++"s);
        cout << FindCollisions(good_hash, stream) << endl;
    }
} 
Вывод:
2
0 
Ограничения
Ваша реализация должна быть эффективна. Будьте готовы, что:
возможна плохая хеш-функция, при которой коллизий будет очень много;
возможна хорошая хеш-функция, при которой коллизий будет мало.
Рекомендуется использовать unordered_map и unordered_set для эффективности реализации.
Сортирующие контейнеры map и set использовать запрещено.
Как будет тестироваться ваш код
Мы проверим, что:
функция правильно находит количество коллизий;
функция работает эффективно для плохих хеш-функций;
функция работает эффективно для хороших хеш-функций;
функция работает эффективно для совсем плохих хеш-функций;
вы не используете map и set.
