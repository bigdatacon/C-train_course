Задание
Задание
В большом сортированном векторе v хранятся случайные числа в диапазоне от нуля до n. Причём все числа встречаются с одинаковой вероятностью. Требуется оценить, сколько точно чисел не превышают заданного числа i.
В этой задаче вы сможете заранее выяснить, будет случай худшим или нет. Скомбинируйте два алгоритма, чтобы всегда оставаться в выигрыше:
в хорошем случае применяйте линейный find_if;
в среднем и плохом — логарифмический upper_bound.
Хорошим будет считаться случай, когда ожидаемый ответ не превышает числа log2(v.size()). Для вычисления границы используйте функцию log2 из библиотеки <cmath>.
Реализуйте функцию int EffectiveCount(const vector<int>& v, int n, int i). Она принимает отсортированный по возрастанию вектор v, содержащий случайные числа от нуля до n. Функция должна вычислять количество чисел в v, не превышающих i. При этом в cout должен выдаваться текст Using find_if либо Using upper_bound в зависимости от того, какой алгоритм вы выбрали.
Ограничения
Не меняйте сигнатуру функции EffectiveCount. Для отделения хорошего случая от остальных используйте порог, описанный в условии.
Пример
Пусть дан вектор из 10000 элементов с числами от 0 до 4999. Требуется найти количество чисел, не превышающих 5. Так как возможных чисел 5000, каждое число встречается в среднем 2 раза. Ожидаемый ответ — 12, так как нас устраивают 6 чисел. Двоичный логарифм числа 10000 примерно равен 13,3, так что выбираем find_if.
Если требуется найти числа до 100, то ожидаемый ответ 202 и мы выбираем upper_bound.
Что отправлять на проверку
Включите в решение реализацию EffectiveCount. Функция main учитываться не будет.
Как будет тестироваться ваш код
Будет проверено, что EffectiveCount правильно находит ответ. Также будет проверено, что она делает это достаточно быстро и пользуется нужным алгоритмом.

Подсказка :
Нужно найти позицию первого числа, большего i. Номер этой позиции будет совпадать с количеством чисел, не превышающих i.
Добавьте if, который позволит выбрать между find_if и upper_bound.
Чтобы оценить ожидаемый ответ, вычислите, какая доля чисел будет меньше, либо равна i. Это можно сделать по формуле: static_cast<int64_t>(v.size())*(i + 1)/(n + 1). Здесь потребовалось преобразование к int64_t — так можно избежать переполнений.
Найдя итератор алгоритмом find_if или upper_bound, возвратите разность между ним и v.begin().
