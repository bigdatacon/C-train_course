Подсказка : 
Напишите вспомогательный метод, который по номиналу купюры определит её индекс в векторе counts_.
Воспользуйтесь индексом, чтобы увеличить счётчик купюр этого номинала.


Задание
Задание
Теперь вам предстоит работать с купюрами, которые могут даже не влезть в int. Улучшите класс MoneyBox, сократив потребление памяти.
В этом задании вы реализуете очень быстрый контейнер. Считайте, что разных номиналов купюр немного, не более 20. В этом случае контейнер должен выполнять операции добавления и получения с замечательной сложностью — O(1)O(1). Программа будет понятной: не понадобятся ни map, ни unordered_map, то есть контейнеры, устройство которых мы пока что не проходили.
В заготовке есть класс MoneyBox. Он хранит в векторе nominals_ все доступные номиналы купюр. Реализуйте его методы:
void PushCoin(int64_t value) — для добавления купюры или монеты в копилку,
void PrintCoins(ostream& out) const — для печати всех доступных средств в поток. Формат вывода будет в примере ниже.
Метод PushCoin должен менять вектор counts_ так, чтобы counts_[i] было количеством добавленных купюр с номиналом nominals_[i].
Требования
В конструктор будет передан вектор возможных номиналов купюр в порядке возрастания. Гарантируется, что все они различны.
Реализуйте функцию добавления купюры в кошелёк, а также функцию печати номиналов.
Выведите в поток вывода количество купюр каждого номинала в том же порядке, в каком номиналы были переданы в конструктор MoneyBox. Количество купюр, равное нулю, выводить не нужно.  
Вектор counts_ обязан хранить количество купюр каждого номинала в том же порядке, в котором эти номиналы перечислены в nominals_.
Ограничения
Не добавляйте в класс заготовки новые поля.
Не меняйте уже реализованные функции.
Считайте, что количество разных номиналов невелико — не более 20.
Пример
int main() {
    MoneyBox cash({1, 500, 10000});
    cash.PushCoin(500);
    cash.PushCoin(500);
    cash.PushCoin(10000);
    assert((cash.GetCounts() == vector<int>{0,2,1}));
    cout << cash << endl;
} 
Вывод:
500: 2
10000: 1 
Как будет тестироваться ваш код
Проверим, что класс выполняет свою задачу и соответствует ограничениям.
