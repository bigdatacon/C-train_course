Подсказка:
Чтобы класс Document был способен хранить произвольные объекты-наследники Object и выводить их в порядке добавления, храните уникальные указатели на них внутри документа в подходящем последовательном контейнере.
Чтобы метод Document::Add мог принимать произвольные объекты-наследники класса Object по значению, сделайте этот метод шаблонным. Затем переместите переданное значение в новый объект того же типа в куче, используя make_unique:
template <typename Obj>
void Add(Obj obj) {
    objects_.emplace_back(std::make_unique<Obj>(std::move(obj)));
} 
Выполняя экранирование особых символов, следите за тем, чтобы ранее экранированные символы не подвергались повторному экранированию. Например, преобразовав символ < в последовательность &lt;, не нужно подвергать содержащийся в этой последовательности & повторному экранированию.

Задание
Это задание — часть итогового задания десятого спринта. Сохраните файлы решения, так как они понадобятся вам при выполнении следующих заданий.
Разработайте простую библиотеку для вывода векторных изображений в формате SVG. Основное применение этой библиотеки в рамках текущего спринта — визуализация «Транспортного справочника»‎. Поэтому достаточно реализовать три типа объектов:
Круг Circle. Описывается координатами центра и радиусом. Этот класс реализован в заготовке кода в качестве примера.
Ломаная Polyline. Описывается координатами вершин.
Текст Text. Описывается текстовым содержимым, координатами опорной точки, смещением относительно опорной точки, размером и названием шрифта.
Весь код библиотеки должен находиться в пространстве имён svg.
Пример использования:
#define _USE_MATH_DEFINES
#include "svg.h" // Объявления классов библиотеки должны быть расположены в файле svg.h

#include <cmath>

using namespace std::literals;
using namespace svg;

Polyline CreateStar(Point center, double outer_rad, double inner_rad, int num_rays) {
    Polyline polyline;
    for (int i = 0; i <= num_rays; ++i) {
        double angle = 2 * M_PI * (i % num_rays) / num_rays;
        polyline.AddPoint({center.x + outer_rad * sin(angle), center.y - outer_rad * cos(angle)});
        if (i == num_rays) {
            break;
        }
        angle += M_PI / num_rays;
        polyline.AddPoint({center.x + inner_rad * sin(angle), center.y - inner_rad * cos(angle)});
    }
    return polyline;
}

int main() {
    Document doc;
    doc.Add(Circle().SetCenter({20, 20}).SetRadius(10));
    doc.Add(Text()
                .SetFontFamily("Verdana"s)
                .SetPosition({35, 20})
                .SetOffset({0, 6})
                .SetFontSize(12)
                .SetFontWeight("bold"s)
                .SetData("Hello C++"s));
    doc.Add(CreateStar({20, 50}, 10, 5, 5));
    doc.Render(std::cout);
} 
Ожидаемый вывод программы (порядок перечисления атрибутов элементов может быть произвольным):
<?xml version="1.0" encoding="UTF-8" ?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="20" cy="20" r="10" />
  <text x="35" y="20" dx="0" dy="6" font-size="12" font-family="Verdana" font-weight="bold">Hello C++</text>
  <polyline points="20,40 22.9389,45.9549 29.5106,46.9098 24.7553,51.5451 25.8779,58.0902 20,55 14.1221,58.0902 15.2447,51.5451 10.4894,46.9098 17.0611,45.9549 20,40" />
</svg> 
Запустив эту программу с перенаправлением её вывода в файл greeting.svg, вы создадите файл, который можно будет открыть в любом современном браузере:
program.exe > greeting.svg 
Визуально изображение будет представлено так:
image
Внутренности ломаной линии оказались залиты чёрным цветом. Так и должно быть — в будущих версиях вы научите библиотеку управлять стилями и цветом фигур.
Требования к классам и структурам
На рисунке представлена упрощённая диаграмма классов библиотеки SVG:
image
svg::Point — структура из двух полей x и y типа double. Должно быть два способа создать точку:
использовать выражение Point{x, y};
создать точку конструктором по умолчанию, а затем задать значения полей x и y прямым обращением к ним.
svg::Object — абстрактный базовый класс для элементов, которые могут находиться внутри SVG-документа. Применяет паттерн проектирования «Шаблонный метод»‎ для отображения тегов.
svg::Document — класс, который производит отрисовку и компоновку SVG-документа. Класс должен поддерживать следующие операции:
Создание с применением конструктора по умолчанию.
svg::Document svg;;
Добавление объекта. svg.Add(object), где object имеет тип Circle, Polyline или Text, а также любой конкретный класс-наследник svg::Object. Так поддерживается лишь линейная структура документа — составляющие его объекты по сути образуют массив;
Добавление объекта. svg.AddPtr(unique_ptr<Object>&& object_ptr) добавляет unique_ptr, ссылающийся на любой класс-наследник svg::Object.
Отрисовка (формирование результирующей строки). svg.Render(out), где out — наследник ostream.
Классы Circle, Polyline и Text должны иметь конструктор по умолчанию и поддерживать описанные ниже методы. Умолчания — значения свойств, когда соответствующий Set-метод не вызывается.
svg::Circle
SetCenter(Point center): задаёт значения свойств cx и cy — координаты центра круга. Значение по умолчанию — точка с координатами {0.0, 0.0}.
SetRadus(double radius): задаёт значение свойства r — радиус круга. Значение по умолчанию — 1.0.
svg::Polyline
AddPoint(Point p): добавляет вершину ломаной — элемент свойства points, записываемый в виде x,y и отделяемый пробелами от соседних элементов (см. примеры). Значение свойства по умолчанию — пустая строка.
svg::Text
SetPosition(Point pos): задаёт значения свойств x и y — координаты текста. Значение по умолчанию — точка с координатами {0.0, 0.0}.
SetOffset(Point offset): задаёт значения свойств dx и dy — величины отступа текста от координаты. Значение по умолчанию — {0.0, 0.0}.
SetFontSize(uint32_t size): задаёт значение свойства font-size — размер шрифта. Значение по умолчанию: 1`.
SetFontWeight(string font_weight): задаёт значение свойства font-weight — толщина шрифта. По умолчанию свойство не выводится.
SetFontFamily(string font_family): задаёт значение свойства font-family — название семейства шрифта. По умолчанию свойство не выводится.
SetData(string data): задаёт содержимое тега <text> — непосредственно выводимый текст. По умолчанию текст пуст.
Set-методы должны поддерживать method chaining (цепочки вызовов методов) — приём, который позволяет сократить запись нескольких вызов методов одного и того же объекта:
Circle c;
c.SetCenter({1, 2}).SetRadius(10);
// Строчка выше аналогична вызовам:
// c.SetCenter({1, 2});
// c.SetRadius(10);

Document doc;
doc.Add(Circle().SetCenter({1, 2}).SetRadius(10)); 
Другое название этого приёма — Fluent interface. Реализуется он путём возврата ссылки на текущий экземпляр класса в Set-методах:
class SomeClass {
public:
    SomeClass& SetProperty(string value) {
        property_ = move(value);
        return *this; // Возврат ссылки на текущий экземпляр
    }
private:
    string property_;
}; 
Формат выходных данных
Содержимое, выводимое методом svg::Document::Render, должно состоять из следующих частей:
<?xml version="1.0" encoding="UTF-8" ?>
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
Объекты, добавленные с помощью svg::Document::Add, в порядке их добавления
</svg>
Все свойства объектов выводятся в следующем формате: название свойства, символ =, затем значение свойства в кавычках.
Лишние пробельные символы допускаются:
Между тегами, за исключением текста между открывающими и закрывающими тегами <text>.
Между свойствами, перед и после списка свойств, вокруг символа =, разделяющего название свойства и значение.
Между координатами в значении свойства points тега polyline должен быть ровно один пробел.  В начале и конце списка координат пробелов быть не должно:
<polyline points="20,40 22.9389,45.9549 29.5106,46.9098" /> 
Круг отображается следующим образом: строка “<circle ”, затем через пробел свойства в произвольном порядке, затем строка “/>”.
Ломаная отображается так: строка “<polyline ”, затем через пробел свойства в произвольном порядке, затем строка “/>”.
Текст отображается следующим образом: строка “<text ”, затем через пробел свойства в произвольном порядке, затем символ “>”, содержимое надписи и, наконец, закрывающий тег “</text>”. Символы ", <, >, ' и & имеют особое значение и при выводе должны экранироваться:
Двойная кавычка " заменяется на &quot;. Точка с запятой в представлении этого и следующих спецсимволов — обязательная часть экранирующей последовательности.
Одинарная кавычка или апостроф ' заменяется на &apos;.
Символы < и > заменяются на &lt; и &gt; соответственно.
Амперсанд & заменяется на &amp;.
Например, текст “Hello, <UserName>. Would you like some "M&M's"?” в SVG файле будет представлен так:
<text>Hello, &lt;UserName&gt;. Would you like some &quot;M&amp;M&apos;s&quot;?</text> 
Вывод вещественных чисел должен осуществляться стандартно, без модификаторов вывода. При тестировании вещественные числа будут сравниваться с относительной точностью 1e-6.
Ограничения
Ограничения допускают любое адекватное линейное решение: за одну секунду нужно обрабатывать порядка 10 000 вызовов конструкторов объектов и методов выставления свойств, а также один вызов метода svg::Document::Render.
Гарантируется, что при тестировании тренажёр будет передавать валидные параметры в методы классов и их конструкторы. Поэтому усложнять код проверками не нужно.
Не вносите изменения в класс svg::Object. В частности, не добавляйте в него чисто виртуальные методы и не изменяйте сигнатуру его методов. В противном случае тренажёр не сможет проверить работу вашей программы.
Что отправлять на проверку
Код библиотеки должен располагаться в файлах svg.h и svg.cpp. Файл main.cpp содержит код, иллюстрирующий использование библиотеки, и проверяться не будет. Функция main будет заменена на версию из тренажёра.
Как будет тестироваться ваш код
Тренажёр проверит работу классов библиотеки: Circle, Polyline, Text, Document, Object, включая вывод SVG-документа.
