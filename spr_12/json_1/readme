Подсказка:
Мы рекомендуем хранить в объекте json::Builder следующее состояние:
Node root_; — сам конструируемый объект.
std::vector<Node*> nodes_stack_; — стек указателей на те вершины JSON, которые ещё не построены: то есть текущее описываемое значение и цепочка его родителей. Он поможет возвращаться в нужный контекст после вызова End-методов.
Начните проектирование кода с описания ожидаемого состояния класса (в первую очередь — последней вершины в стеке) для каждой точки в цепочке вызовов в примере.

Задание 1
Это задание — часть итогового проекта одиннадцатого спринта. Вы будете сдавать его на проверку через репозиторий на GitHub. Не забудьте сохранить верное решение.
Реализуйте класс json::Builder, позволяющий сконструировать JSON-объект, используя цепочки вызовов методов. Этот класс должен быть основан на уже известной вам библиотеке JSON, данной в заготовке решения.
Начнём с простого примера — объекта-строки:
json::Builder{}.Value("just a string"s).Build() 
Это выражение должно быть объектом json::Node и содержать указанную строку. Вывести построенный JSON, как и раньше, можно так:
json::Print(
    json::Document{
        json::Builder{}
        .Value("just a string"s)
        .Build()
    },
    cout
); 
Вывод:
"just a string" 
Более сложный пример демонстрирует все методы builder-класса на более сложном JSON-объекте:
json::Print(
    json::Document{
                // Форматирование не имеет формального значения:
                // это просто цепочка вызовов методов
        json::Builder{}
        .StartDict()
            .Key("key1"s).Value(123)
            .Key("key2"s).Value("value2"s)
            .Key("key3"s).StartArray()
                .Value(456)
                .StartDict().EndDict()
                .StartDict()
                    .Key(""s).Value(nullptr)
                .EndDict()
                .Value(""s)
            .EndArray()
        .EndDict()
        .Build()
    },
    cout
); 
Вывод:
{
    "key1": 123,
    "key2": "value2",
    "key3": [
        456,
        {

        },
        {
            "": null
        },
        ""
    ]
} 
Разберём все методы класса json::Builder. Ниже описана их семантика, и для понимания дан контекст, в котором они вызываются. Ошибки неверного использования методов, которые должны обрабатываться в вашей реализации, буду разобраны ниже.
Key(std::string). При определении словаря задаёт строковое значение ключа для очередной пары ключ-значение. Следующий вызов метода обязательно должен задавать соответствующее этому ключу значение с помощью метода Value или начинать его определение с помощью StartDict или StartArray.
Value(Node::Value). Задаёт значение, соответствующее ключу при определении словаря, очередной элемент массива или, если вызвать сразу после конструктора json::Builder, всё содержимое конструируемого JSON-объекта. Может принимать как простой объект — число или строку — так и целый массив или словарь.
Здесь Node::Value — это синоним для базового класса Node, шаблона variant с набором возможных типов-значений. Смотрите заготовку кода.
StartDict(). Начинает определение сложного значения-словаря. Вызывается в тех же контекстах, что и Value. Следующим вызовом обязательно должен быть Key или EndDict.
StartArray(). Начинает определение сложного значения-массива. Вызывается в тех же контекстах, что и Value. Следующим вызовом обязательно должен быть EndArray или любой, задающий новое значение: Value, StartDict или StartArray.
EndDict(). Завершает определение сложного значения-словаря. Последним незавершённым вызовом Start* должен быть StartDict.
EndArray(). Завершает определение сложного значения-массива. Последним незавершённым вызовом Start* должен быть StartArray.
Build(). Возвращает объект json::Node, содержащий JSON, описанный предыдущими вызовами методов. К этому моменту для каждого Start* должен быть вызван соответствующий End*. При этом сам объект должен быть определён, то есть вызов json::Builder{}.Build() недопустим.
Возвращаемое значение каждого метода, кроме Build, должно быть Builder&.
Описанный синтаксис позволяет указывать ключи словаря в определённом порядке. Тем не менее, в данном случае это учитывать не нужно. Словари всё так же должны храниться с помощью контейнера map.
При реализации обратите внимание на метод emplace_back у вектора: в отличие от push_back он принимает не сам добавляемый объект, а аргументы конструктора этого объекта. Иногда это может быть удобно.
Обработка ошибок
В случае использования методов в неверном контексте ваш код должен выбросить исключение типа std::logic_error с понятным сообщением об ошибке.
Это должно происходить в следующих ситуациях:
Вызов метода Build при неготовом описываемом объекте, то есть сразу после конструктора или при незаконченных массивах и словарях.
Вызов любого метода, кроме Build, при готовом объекте.
Вызов метода Key снаружи словаря или сразу после другого Key.
Вызов Value, StartDict или StartArray где-либо, кроме как после конструктора, после Key или после предыдущего элемента массива.
Вызов EndDict или EndArray в контексте другого контейнера.
Ограничения
Методы класса должны иметь амортизированную линейную сложность относительно размера входных данных. Исключение — дополнительный логарифмический множитель при добавлении в словарь.
Принимайте тяжёлые объекты в методах таким образом, чтобы при вызове этих методов объекты можно было переместить. Например, принимайте по значению и перемещайте в коде метода.
Что отправлять на проверку
Файлы json.h, json.cpp, json_builder.h и json_builder.cpp, содержащие:
Библиотеку для работы с JSON, данную в заготовке. Вы можете вносить в неё косметические изменения.
Класс json::Builder, описанный выше.
Как будет тестироваться ваш код
Работоспособность кода и его соответствие указанным выше требованиям будет проверена юнит-тестами, подобным примерам выше.
Гарантируется, что не будет создаваться переменная типа json::Builder: сразу после конструирования этот объект будет цепочкой методов, оканчивающейся на Build, преобразовываться в json::Node.
