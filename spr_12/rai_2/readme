Подсказка:
Продумайте политику копирования. Класс Booking содержит в себе указатель на Provider. При перемещении объекта класса Booking указатель может становиться nullptr. Подумайте, что в этом случае надо предусмотреть в деструкторе.

Задание:
Задание 2
Теперь вам предстоит сделать так, чтобы отдельные бронирования перелёта и отеля тоже были оформлены в духе RAII. Это позволит упростить класс Trip: в его функции Cancel не придётся вызывать отмены бронирований, достаточно будет просто удалить элементы из векторов.
Вам даны новые версии классов TripManager, Trip, FlightProvider и HotelProvider. Функцию Cancel в новых классах мы переименовали в CancelOrComplete: она должна будет автоматически вызываться не только при отмене бронирования, но и при успешном его завершении. Теперь функции Book и CancelOrComplete в классах-провайдерах возвращают и принимают не BookingId, а специальный класс, который вам и нужно создать.
Так как FlightProvider и HotelProvider имеют одинаковый интерфейс, то, чтобы избежать дублирования кода, мы просим вас разработать шаблонный класс Booking<Provider>, где в качестве шаблонного типа будут выступать FlightProvider и HotelProvider.
Пришлите в тестирующую систему файл booking.h, который:
содержит пространство имён RAII,
внутри пространства имён RAII содержит определение шаблонного класса Booking<Provider>.
Интерфейс класса Booking<Provider> должен стать понятен после изучения файлов new_flight_provider.h, new_hotel_provider.h и new_trip_manager.h.
Ограничения
Не меняйте другие файлы, кроме booking.h.
Что отправлять на проверку
Отправьте на проверку файл booking.h с реализацией класса-шаблона внутри пространства имён RAII.
Как будет тестироваться ваш код
Мы проверим, что все файлы имеют исходный код за исключением booking.h. Ваше решение должно компилироваться и проходить те же тесты, что и в предыдущей задаче.
