Подсказка: 
Как и в предыдущей задаче, можете использовать рекурсию.
Получите папку текущего файла через метод parent_path. Нормализаций и разрешения относительного пути тут не требуется.
Комбинируйте предполагаемую папку и путь из #include-директивы операцией путей /.
Если регулярное выражение нашло вхождение m, получить путь из него можно так: path p = string(m[1]);.
Рекурсивная функция может принимать:
поток ввода
поток вывода,
имя файла, к которому относится поток ввода, чтобы в случае чего выдать ошибку,
вектор include-директорий.
Сохраните регулярные выражения в статические переменные. Не забудьте экранировать кавычки и слеши.
В этой задаче полезно использовать метод is_open класса ifstream, чтобы проверить, был ли открыт файл. Можете применить цикл, который останавливается, если файл успешно открылся.
При чтении строки методом getline не забывайте выводить конец строки самостоятельно.
   
Можете использовать конструктор string для создания строки из нужного количества повторов символа.

Задание
Разработайте препроцессор C++, который будет подставлять содержимое файлов на место #include-директив.
Обрабатывать #define и другие команды препроцессора, а также подставлять макросы в этой задаче не требуется.
Реализуйте функцию:
bool Preprocess(const path& in_file, const path& out_file, 
                const vector<path>& include_directories); 
Она читает in_file и рекурсивно подставляет все #include-зависимости. Результат пишется в out_file.
Функция должна корректно обрабатывать два вида #include-директив:
#include "...", задаваемую регулярным выражением \s*#\s*include\s*"([^"]*)"\s*. В этом случае поиск файла выполняется относительно текущего файла, где расположена сама директива. Если файл не найден, поиск выполняется последовательно по всем элементам вектора include_directories.
#include <...>, задаваемая регулярным выражением \s*#\s*include\s*<([^>]*)>\s*. Поиск выполняется последовательно по всем элементам вектора include_directories.
Чтобы задать эти регулярные выражения в коде, используйте сырой литерал.
Если включаемый файл так и не был найден или его не удалось открыть через ifstream, функция должна вывести в cout следующий текст:
unknown include file <имя файла в директиве> at file <имя файла, где директива> at line <номер строки, где директива> 
И сразу возвратить false. В случае ошибки в выходном файле должны быть записаны все строки до ошибки. При формировании сообщения считайте, что строки нумеруются от единицы.
Если не удалось открыть начальный файл, функция должна сразу возвратить false, ничего не выводя и не открывая выходной файл для записи.
Если все файлы были найдены, функция возвращает true.
Ограничения
Если не удалось открыть входной файл для чтения, не открывайте выходной для записи.
Гарантируется, что:
код, поданный на вход, не содержит циклических зависимостей,
все файлы либо не существуют, либо доступны для открытия через ifstream,
пути в #include-директивах в формате, который может прочитать конструктор path.
Пример
sources/a.cpp
  // this comment before include
  #include "dir1/b.h"
  // text between b.h and c.h
  #include "dir1/d.h"

  void SayHello() {
      std::cout << "hello, world!" << std::endl;
  #   include<dummy.txt>
  }
   
sources/dir1/b.h
  // text from b.h before include
  #include "subdir/c.h"
  // text from b.h after include
   
sources/dir1/subdir/c.h
  // text from c.h before include
  #include <std1.h>
  // text from c.h after include
   
sources/dir1/d.h
  // text from d.h before include
  #include "lib/std2.h"
  // text from d.h after include
   
sources/include1/std1.h
  // std1
   
sources/include2/lib/std2.h
  // std2
   
В качестве include-директорий поданы sources/include1 и sources/include2. Программа должна создать такой файл:
// this comment before include
// text from b.h before include
// text from c.h before include
// std1
// text from c.h after include
// text from b.h after include
// text between b.h and c.h
// text from d.h before include
// std2
// text from d.h after include

void SayHello() {
    std::cout << "hello, world!" << std::endl; 
В cout должен быть выведен текст:
unknown include file dummy.txt at file sources/a.cpp at line 8 
В некоторых операционных системах слеш может быть другим, это допустимо:
unknown include file dummy.txt at file sources\a.cpp at line 8 
Этот пример есть в заготовке кода.
Что отправлять на проверку
Файл main.cpp с реализованной функцией Preprocess.
Как будет тестироваться ваш код
Мы проверим, что:
программа правильно обрабатывает пример из условия,
программа не портит и не создаёт выходной файл, если с открытием входного есть проблемы,
программа правильно работает, если нет ошибок,
программа правильно работает, если ошибки есть,
программа правильно обрабатывает нестандартную расстановку пробелов и табуляций в #include-директиве.
