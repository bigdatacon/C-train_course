Подсказка: 
Не забывайте флаг ios::binary для открытия входного и выходного файлов.
Прочитайте первый символ блока методом get. Если чтение не удалось, значит, архив закончился.
Заголовок блока конвертируйте в unsigned char. Получить данные блока можно так:
  unsigned char header;
  // ...
  int block_type = (header & 1);
  int data_size = (header >> 1) + 1;
   
Можете использовать конструктор string для создания строки из нужного количества повторов символа.

Задание
Компрессор RLE работает таким образом: встречая в файле серию одинаковых символов, заменяет их на один и количество его повторов.
В заготовке кода — программа, которая должна уметь сжимать и разжимать RLE-файлы. Компрессор уже есть в заготовке, ваша задача сделать декомпрессор.
Сжатый файл разбивается на блоки двух типов, которые имеют заголовок и данные.
Заголовок — первый байт блока. Он содержит:
в нулевом бите — тип блока (0 — блок без сжатия, 1 — серия),
в остальных битах — размер распакованных данных минус один.
Данные.
Для блока без сжатия нужно прочитать указанное в заголовке число байт.
Данные блока-серии — это один байт. Такой блок всегда имеет размер два байта. Второй байт должен быть повторён указанное в заголовке число раз.
Чтобы разобраться с форматом архива, изучите исходный код компрессора. Если у вас возникли трудности с получением данных из заголовка блока, загляните в подсказки.
В файле decompressor.h напишите функцию bool DecodeRLE(const std::string& src_name, const std::string& dst_name), которая принимает входной и выходной файлы. Она должна распаковать сжатый бинарный файл src_name и записать результат в бинарный файл dst_name.
Функция, которую вы напишете, должна быть обратной к EncodeRLE, реализованной в файле compressor.h в заготовке кода. Обратной в том смысле, что файл, сжатый через EncodeRLE, должен быть побайтово восстановлен функцией DecodeRLE.
Если входной файл не удалось открыть, нужно возвратить false, не открывая выходной файл на запись.
Ограничения
Не меняйте файлы compressor.h, main.cpp. Редактируйте только decompressor.h.
Гарантируется, что на вход будет подан либо несуществующий файл, либо корректный архив, полученный функцией EncodeRLE. Выходной файл всегда доступен для записи.
Пример
Пример есть в заготовке кода. Также main содержит готовую программу для сжатия и разжатия. Её можно протестировать из командной строки, сжав и разжав любой файл. Если вы решили задачу правильно, то будет всегда получаться исходный файл.
Что отправлять на проверку
Отправьте программу с реализованной функцией DecodeRLE в файле decompressor.h. Вы также можете создать любые вспомогательные функции.
Как будет тестироваться ваш код
Мы проверим:
что вы не изменили компрессор и тесты,
что ваша функция правильно распаковывает сжатый файл,
функция распаковки правильно обрабатывает ошибку открытия файла,
что вы не портите и не создаёте выходной файл, если не удалось открыть входной,
декомпрессор работает эффективно.
