Подсказка:
Определить тип переданных элементов можно так: using Elem = std::decay_t<decltype(*first)>;.
Для каждого выходного параметра сделайте свой тип. Сигнатура может получиться такой:
  template <typename InputIt, typename OutSum, typename OutSqSum, typename OutMax>
  void ComputeStatistics(InputIt first, InputIt last, OutSum& out_sum, OutSqSum& out_sq_sum,
                         OutMax& out_max);
   
Проверяйте, что значение не является nullopt, через std::is_same_v:
  constexpr bool need_sum = !is_same_v<OutSum, const nullopt_t>;
  constexpr bool need_sq_sum = !is_same_v<OutSqSum, const nullopt_t>;
  constexpr bool need_max = !is_same_v<OutMax, const nullopt_t>;
   
  Эти переменные можно использовать в условии if constexpr.

   Задание
Задание
Напишите функцию ComputeStatistics, которая принимает диапазон в виде пары итераторов и вычисляет следующие статистики элементов этого диапазона:
сумму,
сумму квадратов,
максимальный элемент.
Ответы записываются в выходные параметры. Если пользователь указал в качестве выходного параметра nullopt, вычислять соответствующую статистику не нужно. Решение должно приниматься на этапе компиляции.
Вам могут пригодиться:
decltype и std::decay_t — для определения типа входных значений.
std::is_same_v — для определения, передано ли std::nullopt в соответствующий аргумент. Тип, выведенный при передаче в функцию std::nullopt по ссылке, будет const std::nullopt_t.
constexpr переменные.
if constexpr — для выполнения проверки на этапе компиляции.
Если с применением этих концепций у вас возникли трудности, загляните в подсказки.
Ограничения
Функция должна:
Производить вычисления с произвольным типом данных, поддерживающим нужные для вычисления запрошенных статистик арифметические операции.
Поддерживать передачу nullopt в качестве любого выходного параметра. В этом случае вычислять статистику не надо.
Совершать только один проход по диапазону и не делать лишних вычислений.
Считается, что выходные значения имеют тот же тип, что и входные.
В случае передачи пустого диапазона функция не должна менять выходные значения.
Пример
struct OnlySum {
    int value;
};

OnlySum operator+(OnlySum l, OnlySum r) {
    return {l.value + r.value};
}
OnlySum& operator+=(OnlySum& l, OnlySum r) {
    return l = l + r;
}

int main() {
    vector input = {1, 2, 3, 4, 5, 6};
    int sq_sum;
    std::optional<int> max;

    // Переданы выходные параметры разных типов — std::nullopt_t, int и std::optional<int>
    ComputeStatistics(input.begin(), input.end(), nullopt, sq_sum, max);

    assert(sq_sum == 91 && max && *max == 6);

    vector<OnlySum> only_sum_vector = {{100}, {-100}, {20}};
    OnlySum sum;

    // Поданы значения, поддерживающие только суммирование, но и запрошена только сумма
    ComputeStatistics(only_sum_vector.begin(), only_sum_vector.end(), sum, nullopt, nullopt);

    assert(sum.value == 20);
} 
Что отправлять на проверку
Код заготовки с реализованной функцией ComputeStatistics.
Как будет тестироваться ваш код
Будет проверено, что:
ComputeStatistics правильно считает все статистики для числового набора,
ComputeStatistics правильно считает при любом задании нужных статистик,
ComputeStatistics правильно не совершает незапрошенных вычислений,
ComputeStatistics правильно работает с пользовательскими типами, поддерживающими только определённые операции,
ComputeStatistics не изменяет выходной параметр для пустого набора.
